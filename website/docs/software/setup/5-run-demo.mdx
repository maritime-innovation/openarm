---
title: '5. Hands-On: Demo Run'
sidebar_position: 6
---

# Step 5: Hands-On: Demo Run

:::info
**Prerequisites:** Before running the demo, verify these prerequisites are complete:
- ✅ Motor IDs configured and tested (Steps 1, 3)
- ✅ CAN interface configured (Step 2)
- ✅ Motor zero position set to safe values, baudrate matches CAN interface configuration (Step 4)
:::

Now that your basic communication is working, let's run the full OpenArm demo program to test complete system functionality.
More details for control can be found [here](../can).


:::danger ⚠️ READ BEFORE RUNNING DEMO ⚠️

- **ZERO POSITION**: Ensure you have set safe zero positions for all motors
- **EMERGENCY STOP**: Keep emergency stop button within immediate reach at ALL times
- **CLEAR WORKSPACE**: Remove ALL obstacles, tools, and personnel from arm movement area
- **POWER DISCONNECT**: Know how to quickly disconnect power if needed

**Failure to follow these safety requirements may result in serious injury or equipment damage.**
:::



Connect the motors in a daisy-chain using XT30 2+2 cables. [See detailed wiring instructions →](/hardware/wiring-and-casing-guide/components)

The default demo uses motors 0x01, 0x02, 0x07 (DM4310) on CAN0 with CANFD. If your setup matches, run directly:

```bash
openarm-can-demo
```

## Event Demo: Move IDs 1 to 8

For event demos where you want to move all configured IDs (`0x01` to `0x08`), use a full ID map and run a simple sequential position routine.

### 1) Configure all motor IDs

In `examples/demo.cpp`, set IDs to match the standard OpenArm mapping:

```cpp
// Arm joints: J1-J7
std::vector<openarm::damiao_motor::MotorType> motor_types = {
    openarm::damiao_motor::MotorType::DM8009, // J1
    openarm::damiao_motor::MotorType::DM8009, // J2
    openarm::damiao_motor::MotorType::DM4340, // J3
    openarm::damiao_motor::MotorType::DM4340, // J4
    openarm::damiao_motor::MotorType::DM4310, // J5
    openarm::damiao_motor::MotorType::DM4310, // J6
    openarm::damiao_motor::MotorType::DM4310  // J7
};

std::vector<uint32_t> send_can_ids = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
std::vector<uint32_t> recv_can_ids = {0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17};

// Gripper: J8
openarm.init_gripper_motor(openarm::damiao_motor::MotorType::DM4310, 0x08, 0x18);
```

### 2) Add a simple sequential motion loop

After motors are enabled, add a routine that moves one joint at a time with conservative targets:

```cpp
// Demo: move IDs 1-7 one-by-one using small position offsets.
const float kSmallTargetRad = 0.15f;

for (size_t i = 0; i < send_can_ids.size(); ++i) {
    std::vector<openarm::damiao_motor::MITParam> cmd(send_can_ids.size(),
        openarm::damiao_motor::MITParam{2.0f, 1.0f, 0.0f, 0.0f, 0.0f});

    cmd[i] = openarm::damiao_motor::MITParam{2.0f, 1.0f, kSmallTargetRad, 0.0f, 0.0f};
    openarm.get_arm().mit_control_all(cmd);
    openarm.recv_all(800);
    std::this_thread::sleep_for(std::chrono::milliseconds(300));

    cmd[i] = openarm::damiao_motor::MITParam{2.0f, 1.0f, 0.0f, 0.0f, 0.0f};
    openarm.get_arm().mit_control_all(cmd);
    openarm.recv_all(800);
    std::this_thread::sleep_for(std::chrono::milliseconds(300));
}

// ID 8 (gripper) open/close demo
openarm.get_gripper().open();
openarm.recv_all(1000);
std::this_thread::sleep_for(std::chrono::milliseconds(400));
openarm.get_gripper().close();
openarm.recv_all(1000);
```

:::warning
Start with very small target values and low speed/torque limits. Increase gradually only after confirming safe motion and correct zero positions.
:::

## Bimanual Demo: Use can0 and can1

For dual-arm setups, run each arm on its own CAN bus:

- Right arm: `can0`
- Left arm: `can1`

### 1) Bring up both CAN interfaces

```bash
openarm-can-configure-socketcan can0 -fd -b 1000000 -d 5000000
openarm-can-configure-socketcan can1 -fd -b 1000000 -d 5000000
```

### 2) Verify traffic on each bus

Use separate terminals:

```bash
candump can0
```

```bash
candump can1
```

### 3) If you use `openarm-can-demo` (C++ demo)

`openarm_can/examples/demo.cpp` uses one interface per process. Select the interface in code:

```cpp
openarm::can::socket::OpenArm openarm("can0", true);
```

Switch to `"can1"` for the other arm and run as a separate process (or on another machine/controller).

### 4) If you use ROS2 bimanual control

Use explicit left/right CAN mapping:

```bash
ros2 launch openarm_description openarm.bimanual.launch.py \
  right_can_interface:=can0 \
  left_can_interface:=can1
```

:::tip
If both arms share the same CAN ID set (`0x01` to `0x08`), keep them on separate buses (`can0` and `can1`) to avoid ID conflicts.
:::

## What the Demo Does

The demo program performs these operations:

1. **Initialization**: Sets up CAN interface and motor communication
2. **Motor Query**: Reads and displays motor IDs to verify configuration
3. **Motor Control**:
   - Enables all motors
   - Performs position control tests
   - Performs torque control tests
4. **Gripper Control**: Opens and closes the gripper (if configured)
5. **Status Monitoring**: Displays motor positions for 10 cycles
6. **Cleanup**: Safely disables all motors

Modify the configuration as needed for your setup.

## Expected Output

You should see output similar to:

```
=== OpenArm CAN Example ===
This example demonstrates the OpenArm API functionality
Initializing OpenArm CAN...
Initializing gripper...

=== Enabling Motors ===

=== Querying Motor Recv IDs ===
Arm Motor: 1 ID: 17
Arm Motor: 2 ID: 18
Gripper Motor: 8 ID: 24

=== Controlling Motors ===
Closing gripper...
Arm Motor: 1 position: 0.123
Arm Motor: 2 position: 0.456
Gripper Motor: 8 position: 0.789
...
```

## Configure the Demo

### Prerequisites

Before proceeding, ensure you have the required system:

- Linux with SocketCAN support ([Install Ubuntu →](../ubuntu/))
- CMake 3.22+
- C++17 compiler

### Download the CAN Library

```bash
wget https://github.com/enactic/openarm_can/releases/download/{{OPENARM_CAN_VERSION}}/openarm-can-{{OPENARM_CAN_VERSION}}.tar.gz
tar xf openarm-can-{{OPENARM_CAN_VERSION}}.tar.gz
cd openarm-can-{{OPENARM_CAN_VERSION}}
```

### Configure the Demo

Configured with your specific motor setup by editing `examples/demo.cpp` and build if needed.
Find and update these sections to match your motor setup:

```cpp
// Initialize arm motors
std::vector<openarm::damiao_motor::MotorType> motor_types = {
    openarm::damiao_motor::MotorType::DM4310,
    openarm::damiao_motor::MotorType::DM4310
};
std::vector<uint32_t> send_can_ids = {0x01, 0x02};  // Your motor send IDs
std::vector<uint32_t> recv_can_ids = {0x11, 0x12};  // Your motor receive IDs
```

**Example configurations:**

**7-motor arm:**
```cpp
std::vector<openarm::damiao_motor::MotorType> motor_types = {
    openarm::damiao_motor::MotorType::DM8009,
    openarm::damiao_motor::MotorType::DM8009,
    openarm::damiao_motor::MotorType::DM4340,
    openarm::damiao_motor::MotorType::DM4340,
    openarm::damiao_motor::MotorType::DM4310,
    openarm::damiao_motor::MotorType::DM4310,
    openarm::damiao_motor::MotorType::DM4310
};
std::vector<uint32_t> send_can_ids = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
std::vector<uint32_t> recv_can_ids = {0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17};
```

:::warning
Ensure all three vectors (motor_types, send_can_ids, recv_can_ids) have the same length to avoid undefined behavior.
:::


**gripper**

If you have a gripper, update the gripper configuration. Otherwise, remove all code using the gripper.

```cpp
// Initialize gripper
openarm.init_gripper_motor(openarm::damiao_motor::MotorType::DM4310, 0x08, 0x18);
```

### Build the Demo

After modifying the configuration, build the demo:

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build --target openarm-can-demo
```

### Run the Demo

```bash
build/openarm-can-demo
```

## Troubleshooting

- Use `candump` to monitor CAN communication
- Verify motor power supply (24V)
- Check cable connections (especially for daisy-chained setups)


## What's Next

Congrats! You have completed the basic setup.
If the demo runs successfully, you can now develop custom applications using the OpenArm API or try ROS2 integration.
